---
layout: "layout"
permalink: /W08/
---

# Top 10 List of Week 08

1. [CPU Scheduling in Operating System](https://www.studytonight.com/operating-system/cpu-scheduling)<br>
CPU scheduling merupakan proses yang mengizinkan suatu proses untuk menggunakan CPU sementara proses yang sedang tereksekusi ditunda dan berada di posisi waiting state. Ketika CPU sedang berada di posisi idle, OS perlu memilih proses dari ready queue. CPU Scheduling inilah yang akan memilih proses untuk dialokasikan ke CPU dan dieksekusi. Situs ini juga menjelaskan bahwa ada suatu komponen yaitu Dispatcher yang memberi kontrol kepada pemilihan proses tersebut. Dispatcher ini dipanggil setiap pertukaran proses sehingga terdapat Dispatch Latency yang merupakan waktu yang dibutuhkan sejak dispatcher menghentikan satu proses dan memulai proses yang lainnya.  

2. [Scheduling Criteria](https://www.youtube.com/watch?v=bWHFY8-rL5I)<br>
Video ini menjelaskan tentang perbedaan-perbedaan Scheduling Criteria berdasarkan apa yang kita dapat bedakan dari Scheduling Algorithm. Ketika kita memiliki Scheduling Algorithm, berdasarkan "hal" apa kita ingin membandingkannya atau "basis" apa yang akan kita putuskan atau bagaimana efisiensinya, maka kita memerlukan criteria untuk hal tersebut. Terdapat 5 Scheduling Criteria yang dijelaskan secara detil oleh video ini, yaitu CPU utilization, Throughput, Turnaround time, Waiting time, dan Response time. 

3. [Difference Between Preemptive and Non-Preemptive Scheduling in OS](https://techdifferences.com/difference-between-preemptive-and-non-preemptive-scheduling-in-os.html)<br>
Scheduling yang terjadi saat proses berpindah dari running state ke ready state atau waiting state ke ready state merupakan Preemptive Scheduling. Sementara scheduling yang terjadi saat proses berhenti atau berpindah dari running state ke waiting state merupakan Non-preemptive Scheduling. Situs ini menjelaskan perbedaan keduanya dari banyak aspek, misalnya pada preemptive scheduling proses bisa diinterrupt sementara pada non-preemptive tidak. Pada preemptive, proses dialokasikan ke resource pada waktu yang terbadas sementara pada non preemptive, proses dialokasikan hingga berpindah ke waiting state.

4. [Scheduling Algorithms](https://www.javatpoint.com/os-scheduling-algorithms)<br>
Terdapat beberapa algoritma yang digunakan Operating System untuk melakukan scheduling agar tercapai efisiensi. First Come First Serve merupakan algoritma di mana semakin minimal arrival time nya maka proses akan semakin cepat dialokasikan ke CPU. Pada Round Robin algorithm, proses akan dijalankan pada rangkaian siklis pada waktu yang singkat(time quantum) dan akan kembali ke queue untuk menunggu giliran lagi. Selain itu, situs ini juga menjelaskan algoritma lainnya berdasarkan hal tertentu, di antaranya Shortest Job First, Shortest Remaining Time First, Priority Based Scheduling, dan Highest Response Ratio Next. 

5. [Short-term vs medium-term vs long-term scheduling](https://www.tutorialspoint.com/short-term-vs-medium-term-vs-long-term-scheduling)<br>
Situs ini menjelaskan perbedaan antara ketiga term Scheduling. Long-term scheduling melibatkan pemilihan proses dari storage pool ke secondary memory dan dilakukan load ke ready queue di main memory untuk dieksekusi. Short term scheduling melibatkan pemilihan proses dari ready queue dan dilakukan Scheduling untuk eksekusi. Short-term ini lebih sering dijalankan dari Long-term. Pada short-term, dibutuhkan pemilihan proses yang tepat karena jika memiliki proses dengan burst time yang panjang, maka proses yang sedang berada di ready queue harus menunggu lama. Sementara Medium-term scheduling melibatkan pertukaran proses dari mein memory. 

6. [Round Robin Scheduling Algorithm with Example](https://www.guru99.com/round-robin-scheduling-example.html)<br>
Penamaan algoritma ini didasarkan pada Round Robin Principle di mana setiap orang mendapatkan jatah yang sama dari sesuatu secara bergilir. Biasanya algoritma ini digunakan untuk multitasking. Karena saya penasaran dengan Round Robin Algorithm, sepertinya situs ini adalah situs yang tepat karena menggambarkan bagaimana cara kerja algoritma tersebut secara rinci. Situs ini juga menjelaskan banyaknya keuntungan penggunaan algoritma ini seperti performance yang terbaik dalam hal average response time, ketidakbergantungan pada burst time dan prioritas, dll. Walaupun demikian, terdapat drawback dari algoritma ini yang juga dijelaskan pada situs. Juga terdapat bagaimana cara menghitung worst case latency untuk algoritma ini. 

7. [Thread scheduling](https://padakuu.com/article/100-thread-scheduling)<br>
Salah satu perbedaan antara user-level dan kernel-level threads terletak pada Schedulingnya. Pada sistem yang mengimplementasikan Many-to-One dan Many-to-Many, Thread Library akan menjadwalkan user-level untuk bisa dijalankan di LWP, Skema yang diketahui sebagai PCS, yang tersedia berhubung adanya kompetisi untuk CPU terjadi antara threads pada proses yang sama. Dengan kaya lain, hal ini mengharuskan OS untuk Scheduling ke kernel thread atas physical CPU. Untuk menentukan kernel-thread yang mana, kernel menggunakan System-Contention Scope. Namun system yang menggunakan model One-to-One, Thread Scheduling hanya menggunakan SCS.

8. [Multiple-Processor Scheduling in Operating System](https://www.geeksforgeeks.org/multiple-processor-scheduling-in-operating-system/)<br>
Pada Multiple-Processor Scheduling, tersedia multiple CPU sehingga Load Sharing mungkin terjadi, yang tentunya Multiple-Processor Scheduling akan lebih kompleks daripada Single Processor Scheduling. Pendekatan dari Multiprocessor Scheduling adalah ketika penentuan Scheduling dan I/O processing dihandle oleh Master Server dan processor lain hanya mengeksekusi user code (Asymmetric Multiprocessing). Pendekatan lainnya adalah ketika setiap processor melakukan self scheduling di mana semua proses mungkin bisa berada di queue atau private queue (Symmetric Multiprocessing)

9. [Scheduling in Real Time Systems](https://www.geeksforgeeks.org/scheduling-in-real-time-systems/)<br>
Real-time system merupakan system yang menghandle task yang dijalankan segera dengan tingkat urgensi tertentu. Dengan kata lain, system ini menghandle task terkait pengendalian events. Dalam real-time system, Scheduler merupakan komponen terpenting, yaitu short-term task scheduler. Fokus utama scheduler adalah untuk mengurangi response time yang berasosiasi dengan masing-masing proses daripada menghandle deadline. Situs ini menjabarkan Scheduling Algorithm untuk Real-time system di antaranya Static table-driven, Static priority-driven, Dynamic panning-based, dan Dynamic best effort.

10. [Multilevel Queue Scheduling Algorithm](https://www.studytonight.com/operating-system/multilevel-queue-scheduling)<br>
Algoritma ini dibuat untuk situasi di mana proses diklasifikasi ke dalam beberapa group yang berbeda. Dengan adanya algoritma ini, kita bisa menerapkan banyak jenis scheduling untuk proses yang berbeda. Namun, terdapat kekurangan dari Multilevel Queue Scheduling ini, yaitu starvation di mana starvation ini bisa menyebabkan proses yang tidak pernah dieksekusi atau harus menunggu lama karena priority yang lebih rendah/lebih tinggi terjadi proses dengan waktu yang lama. Situs ini juga memberikan contoh implementasi dari Multilevel Queue Scheduling.
